<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.hemajoo.education</groupId>
    <artifactId>vaadin-parent</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>pom</packaging>

    <modules>
        <module>../vaadin-commons</module>
        <module>../vaadin-utilities</module>
        <module>../vaadin-web</module>
    </modules>

    <developers>

        <developer>
            <id>ressec</id>
            <roles>
                <role>Lead Developer</role>
            </roles>
            <name>Resse Christophe</name>
            <url>https://github.com/hemajoo</url>
            <email>christophe.resse@gmail.com</email>
        </developer>

    </developers>

    <properties>

        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>

        <!-- Dependencies -->
        <version.spring.boot>3.1.5</version.spring.boot>
        <version.vaadin>24.2.2</version.vaadin>
        <version.junit.jupiter>5.9.2</version.junit.jupiter>
        <version.junit.platform.launcher>1.9.2</version.junit.platform.launcher>
        <version.testcontainers>1.18.0</version.testcontainers>
        <version.assertj>3.24.2</version.assertj>
        <version.lombok>1.18.28</version.lombok>
        <version.slf4j>2.0.7</version.slf4j>

        <version.jackson>2.15.2</version.jackson>
        <version.apache.commons-lang3>3.12.0</version.apache.commons-lang3>
        <version.apache.commons-io>2.11.0</version.apache.commons-io>
        <version.apache.commons.validator>1.7</version.apache.commons.validator>

        <!-- Maven plugins -->
        <version.maven.plugin.compiler>3.10.1</version.maven.plugin.compiler>
        <version.maven.plugin.jar>3.2.2</version.maven.plugin.jar>
        <version.maven.plugin.javadoc>3.4.0</version.maven.plugin.javadoc>
        <version.maven.plugin.source>3.2.1</version.maven.plugin.source>
        <version.maven.plugin.scm>2.0.0-M1</version.maven.plugin.scm>
        <version.maven.plugin.release>3.0.0-M5</version.maven.plugin.release>
        <version.maven.plugin.site>3.11.0</version.maven.plugin.site>
        <version.maven.plugin.project.info.reports>3.2.2</version.maven.plugin.project.info.reports>
        <version.maven.plugin.surefire>3.0.0-M5</version.maven.plugin.surefire>
        <version.maven.plugin.failsafe>3.0.0-M5</version.maven.plugin.failsafe>
        <version.maven.plugin.flyway>8.5.2</version.maven.plugin.flyway>
        <version.plugin.maven.docker>0.37.0</version.plugin.maven.docker>
        <version.plugin.maven.sonarscource.scanner>3.9.1.2184</version.plugin.maven.sonarscource.scanner>
        <version.plugin.maven.jacoco>0.8.10</version.plugin.maven.jacoco>

    </properties>

    <repositories>

        <repository>
            <id>Maven Central</id>
            <name>Maven Central</name>
            <url>https://repo.maven.apache.org/maven2</url>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </repository>

        <repository>
            <id>Vaadin Directory</id>
            <url>https://maven.vaadin.com/vaadin-addons</url>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </repository>

        <repository>
            <id>hemajoo-maven-public</id> <!-- Must match one entry in the server section with the same id -->
            <name>AWS Hemajoo - Public Maven Registry (Snapshots)</name>
            <url>s3://hemajoo-maven-public</url>
            <snapshots>
                <enabled>true</enabled>
            </snapshots>
            <releases>
                <enabled>true</enabled>
            </releases>
        </repository>

        <repository>
            <id>hemajoo-maven-private</id> <!-- Must match one entry in the server section with the same id -->
            <name>AWS Hemajoo - Private Maven Registry (Releases)</name>
            <url>s3://hemajoo-maven-private</url>
            <snapshots>
                <enabled>true</enabled>
            </snapshots>
            <releases>
                <enabled>true</enabled>
            </releases>
        </repository>

    </repositories>

    <distributionManagement>
        <snapshotRepository>
            <id>hemajoo-maven-public</id> <!-- Must match one entry in the server section with the same id -->
            <name>AWS Hemajoo - Public Maven Registry (Snapshots)</name>
            <url>s3://hemajoo-maven-private</url>
        </snapshotRepository>

        <repository>
            <id>hemajoo-maven-public</id> <!-- Must match one entry in the server section with the same id -->
            <name>AWS Hemajoo - Public Maven Registry (Releases)</name>
            <url>s3://hemajoo-maven-private</url>
        </repository>
    </distributionManagement>

    <dependencyManagement>

        <dependencies>

            <!-- Spring Boot Dependencies: Spring Boot Dependencies is a curated list of dependencies and their corresponding versions that are known to work well together with a specific version
                 of Spring Boot. It is essentially a bill of materials (BOM) that lists the compatible versions of various dependencies that are needed to build a Spring Boot application.
                 The Spring Boot Dependencies module is used to ensure that all the dependencies in a Spring Boot application are properly aligned and compatible with each other. This helps to
                 reduce the risk of dependency conflicts and version mismatches that can cause compatibility issues and other problems.
                 The Spring Boot Dependencies module is typically included as a parent dependency in a Spring Boot project's pom.xml (Maven) or build.gradle (Gradle) file. By doing so, it provides
                 a set of default dependency management configurations that can be overridden if necessary.
                 By using the Spring Boot Dependencies module, developers can be confident that they are using a well-tested and compatible set of dependencies that are known to work well together
                 with a specific version of Spring Boot. This can help to simplify the process of managing dependencies and ensure that the application is built on a solid foundation. -->
            <!-- See: https://spring.io/projects/spring-boot -->
            <!-- Spring Boot BOM (Bill Of Materials) -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${version.spring.boot}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!-- Spring Boot Starter: The Spring Boot Starter is a set of convenient dependencies that make it easy to bootstrap a Spring Boot application. It is essentially a collection of common
                 dependencies and configurations that are typically used together when building a Spring Boot application.
                 The Spring Boot Starter includes a variety of modules, each of which provides a specific set of functionality. For example, the spring-boot-starter-web module provides everything
                 you need to build a web application, including a web server, Spring MVC, and related dependencies. Other modules include spring-boot-starter-data-jpa for working with databases
                 using the Java Persistence API (JPA), and spring-boot-starter-test for testing Spring Boot applications.
                 Using the Spring Boot Starter can significantly simplify the process of building a Spring Boot application, as it eliminates the need to manually configure and manage dependencies.
                 Instead, you can simply add the desired starter module to your project's dependencies, and Spring Boot will automatically configure the necessary components for you. This makes it
                 easier to get started with Spring Boot, and can also help to reduce the amount of boilerplate code required when building an application. -->
            <!-- See: https://www.baeldung.com/spring-boot-starters -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter</artifactId>
                <version>${version.spring.boot}</version>
            </dependency>

            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-devtools</artifactId>
                <version>${version.spring.boot}</version>
                <optional>true</optional>
            </dependency>

            <!-- Spring Boot Starter Test: Spring Boot Starter Test is a dependency that provides a set of tools and utilities for testing Spring Boot applications. The purpose of this starter is
                 to simplify and streamline the process of writing tests for Spring Boot applications, by providing common dependencies and configurations required for testing.
                 The Spring Boot Starter Test includes several modules, including:
                 * JUnit - a popular testing framework for Java applications
                 * Spring Test - a module that provides integration testing support for Spring applications
                 * Spring Boot Test - a module that provides additional testing features for Spring Boot applications, such as the ability to start up an embedded server and load application
                   contexts for testing
                 * AssertJ - a library that provides a fluent API for writing assertions in Java
                 * Mockito - a popular Java mocking framework for creating mock objects in unit tests
                 By using the Spring Boot Starter Test, developers can easily set up and run tests for their Spring Boot applications without having to manually configure dependencies or write
                 boilerplate code. This makes testing faster, easier, and more reliable, helping developers to catch bugs and errors early in the development process. -->
            <!-- See: https://docs.spring.io/spring-boot/docs/1.5.7.RELEASE/reference/html/boot-features-testing.html -->
            <!-- See: https://www.baeldung.com/spring-boot-testing -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-test</artifactId>
                <version>${version.spring.boot}</version>
                <scope>test</scope>
                <exclusions>
                    <exclusion>
                        <groupId>junit</groupId>
                        <artifactId>junit</artifactId>
                    </exclusion>
                    <exclusion>
                        <groupId>org.junit.vintage</groupId>
                        <artifactId>junit-vintage-engine</artifactId>
                    </exclusion>
                </exclusions>
            </dependency>

            <!-- Spring Boot Configuration Processor: The Spring Boot Configuration Processor is a module that generates metadata about configuration properties in a Spring Boot application. It is
                 essentially a tool that automatically generates documentation and metadata for application properties, making it easier to understand and configure Spring Boot applications.
                 When a Spring Boot application is compiled, the Configuration Processor generates metadata based on the configuration properties that are defined in the application's source code.
                 This metadata includes information such as the property name, type, and default value, as well as documentation about the property and any constraints that may apply.
                 The generated metadata is then used to provide better support for autoconfiguration, documentation, and IDE tooling. For example, IDEs can use the metadata to provide code
                 completion and validation for configuration properties, making it easier for developers to configure the application correctly. The metadata can also be used to generate
                 documentation for the application's configuration properties, which can be particularly useful when sharing or distributing the application.
                 The Spring Boot Configuration Processor is typically included as a dependency in a Spring Boot project's pom.xml (Maven) or build.gradle (Gradle) file. Once included, it will
                 automatically generate the configuration metadata when the application is compiled, making it easier to understand and configure the application. -->
            <!-- See: https://www.baeldung.com/spring-boot-configuration-metadata -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-configuration-processor</artifactId>
                <optional>true</optional>
            </dependency>

            <!-- Spring Boot Starter Data JPA: The DAO layer usually consists of a lot of boilerplate code that can and should be simplified. The advantages of such a simplification are many:
                 a decrease in the number of artifacts that we need to define and maintain, consistency of data access patterns, and consistency of configuration.
                 Spring Data takes this simplification one step further and makes it possible to remove the DAO implementations entirely. The interface of the DAO is now the only artifact that we
                 need to explicitly define.
                 In order to start leveraging the Spring Data programming model with JPA, a DAO interface needs to extend the JPA specific Repository interface, JpaRepository. This will enable
                 Spring Data to find this interface and automatically create an implementation for it.
                 By extending the interface, we get the most relevant CRUD methods for standard data access available in a standard DAO. -->
            <!-- See: https://www.baeldung.com/the-persistence-layer-with-spring-data-jpa -->
            <!-- See: https://spring.io/guides/gs/accessing-data-jpa/ -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-data-jpa</artifactId>
                <version>${version.spring.boot}</version>
            </dependency>

            <!-- Starter module for building web applications with Spring Boot. It provides a set of common dependencies and configurations to help you quickly set up a web application with Spring
                 Boot.
                 The spring-boot-starter-web dependency includes the following modules:
                 - Spring MVC: a framework for building web applications with Spring
                 - Spring Web: a module for building web applications with Spring
                 - Jackson: a library for working with JSON data in Java
                 - Tomcat: a web server and servlet container for Java
                 - Spring Boot: autoconfiguration and starter dependencies for Spring Boot
                 By including the spring-boot-starter-web dependency in your project, you get all the necessary dependencies and configurations for building a web application with Spring Boot. You
                 can then build and run your web application as a standalone executable JAR file, or deploy it to a servlet container such as Tomcat or Jetty. -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-web</artifactId>
                <exclusions>
                    <exclusion>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-starter-logging</artifactId>
                    </exclusion>
                </exclusions>
            </dependency>

            <!-- Spring Boot Starter Validation: Spring Boot Starter Validation is a module that provides support for validating data in a Spring Boot application. It is essentially a collection of
                 dependencies and configuration that are required for validating data using the Java Bean Validation API (JSR 380).
                 The Java Bean Validation API defines a set of annotations and interfaces that can be used to validate data in Java classes. These annotations can be used to specify constraints on
                 the values of properties in a Java class, such as minimum and maximum values, regular expression patterns, and required fields.
                 The Spring Boot Starter Validation includes the necessary dependencies for working with the Java Bean Validation API, including the Hibernate Validator implementation, which is the
                 reference implementation of the API. It also provides default configurations for validation that can be customized if necessary.
                 By using the Spring Boot Starter Validation, developers can easily add validation to their Spring Boot applications without having to manually configure dependencies or write
                 boilerplate code. This can help to ensure that data is validated properly and reduce the likelihood of errors and bugs caused by invalid data. -->
            <!-- See: https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot-starters -->
            <!-- See: https://springframework.guru/bean-validation-in-spring-boot/ -->
            <!-- See: https://www.baeldung.com/spring-boot-bean-validation -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-validation</artifactId>
            </dependency>

            <!-- The spring-boot-starter-cache dependency is a Spring Boot starter that provides caching support for a Spring Boot application.
                 Caching is a technique used to improve the performance of an application by storing frequently accessed data in memory so that it can be quickly retrieved when needed. The
                 spring-boot-starter-cache dependency provides a simple and easy-to-use caching framework that can be used to cache method results, web content, and other types of data.
                 When the spring-boot-starter-cache dependency is added to a Spring Boot application, it automatically configures and enables caching using a default configuration. The starter
                 includes several caching providers, such as Ehcache, Hazelcast, and Redis, which can be used to store cached data. -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-cache</artifactId>
                <version>${version.spring.boot}</version>
            </dependency>

            <!-- The spring-boot-starter-data-mongodb is a dependency provided by the Spring Boot framework that allows easy configuration and usage of the MongoDB database in a Spring Boot
                 application.
                 This starter dependency includes the necessary dependencies to work with MongoDB in a Spring Boot project, such as the MongoDB driver, Spring Data MongoDB, and other related
                 libraries. It also includes autoconfiguration classes that can configure a MongoDB connection based on the properties defined in the application configuration file. -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-data-mongodb</artifactId>
                <version>${version.spring.boot}</version>
            </dependency>


            <dependency>
                <groupId>org.springframework.data</groupId>
                <artifactId>spring-data-commons</artifactId>
                <version>${version.spring.boot}</version>
            </dependency>

            <!-- Junit Platform Launcher: JUnit Platform Launcher is a module that provides a test execution framework for running JUnit tests in a variety of different environments. It is
                 essentially a tool that enables the execution of JUnit tests in different environments, such as command line, build tools, and IDEs.
                 The JUnit Platform Launcher is responsible for discovering, organizing, and executing JUnit tests. It is designed to be extensible, meaning that it can be used with a variety of
                 different testing frameworks, including JUnit 4, JUnit 5, and other testing frameworks that support the JUnit Platform.
                 The JUnit Platform Launcher provides a command line interface for running tests from the command line, as well as an API that can be used to programmatically execute tests. It also
                 supports parallel test execution, which can help to speed up the test execution process for large test suites.
                 The JUnit Platform Launcher is typically included as a dependency in a project's pom.xml (Maven) or build.gradle (Gradle) file when using JUnit tests. It can be used with a variety
                 of different build tools and IDEs, making it a versatile tool for executing JUnit tests in different environments. -->
            <!-- See: https://junit.org/junit5/docs/current/user-guide/ -->
            <!-- See: https://www.baeldung.com/junit-5 -->
            <dependency>
                <groupId>org.junit.platform</groupId>
                <artifactId>junit-platform-launcher</artifactId>
                <version>${version.junit.platform.launcher}</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.junit.jupiter</groupId>
                <artifactId>junit-jupiter</artifactId>
                <version>${version.junit.jupiter}</version>
                <scope>test</scope>
            </dependency>

            <!-- AssertJ Core: AssertJ Core is a Java library that provides a set of fluent assertions for testing Java code. It is essentially a tool that simplifies writing and maintaining
                 assertions in unit tests, making it easier to write tests that are easier to read and maintain.
                 AssertJ Core provides a rich set of assertions that cover many common use cases, including assertions for strings, collections, arrays, and numbers. It also provides a set of
                 custom assertions that can be used to test specific domain objects, such as custom data types or business logic.
                 One of the key features of AssertJ Core is its fluent API, which allows assertions to be written in a natural language style that is easy to read and understand. This can help to
                 make tests more expressive and easier to maintain over time.
                 AssertJ Core is typically included as a dependency in a project's pom.xml (Maven) or build.gradle (Gradle) file when using JUnit tests. It can be used with a variety of different
                 testing frameworks, including JUnit and TestNG, making it a versatile tool for writing unit tests in Java. -->
            <!-- See: https://github.com/assertj/assertj -->
            <dependency>
                <groupId>org.assertj</groupId>
                <artifactId>assertj-core</artifactId>
                <version>${version.assertj}</version>
                <scope>test</scope>
            </dependency>

            <!-- Test Containers: Testcontainers is a Java testing library that provides a set of utilities for running Docker containers as part of JUnit test suites. It is designed to make it easy
                 to write integration tests that require external services such as databases, message queues, or web services.
                 With Testcontainers, developers can define a set of Docker images to be used for testing, and then start and stop those containers as part of their JUnit tests. This allows for a
                 more realistic testing environment, since the tests are running against the same containerized services that will be used in production.
                 Testcontainers supports a wide range of popular databases, message queues, and other services, and provides a simple and consistent API for configuring and managing those containers
                 in tests. It also integrates with popular Java testing frameworks such as JUnit and TestNG, making it easy to incorporate containerized testing into existing test suites.
                 Testcontainers is an open source library and is available under the Apache 2.0 license. It is widely used in Java projects and has a large and active community of developers and
                 users. -->
            <!-- See: https://www.testcontainers.org -->
            <!-- TestContainers BOM (Bill Of Materials) -->
            <dependency>
                <groupId>org.testcontainers</groupId>
                <artifactId>testcontainers-bom</artifactId>
                <version>${version.testcontainers}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <dependency>
                <groupId>org.testcontainers</groupId>
                <artifactId>testcontainers</artifactId>
                <version>${version.testcontainers}</version>
                <scope>test</scope>
            </dependency>

            <dependency>
                <groupId>org.testcontainers</groupId>
                <artifactId>junit-jupiter</artifactId>
                <version>${version.testcontainers}</version>
                <scope>test</scope>
            </dependency>

            <dependency>
                <groupId>com.vaadin</groupId>
                <artifactId>vaadin-bom</artifactId>
                <version>${version.vaadin}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <dependency>
                <groupId>com.vaadin</groupId>
                <artifactId>vaadin-testbench-junit5</artifactId>
                <version>${version.vaadin}</version>
                <scope>test</scope>
            </dependency>

            <dependency>
                <groupId>com.vaadin</groupId>
                <artifactId>vaadin-core</artifactId> <!-- Replace artifactId with 'vaadin' to use not only free components -->
                <version>${version.vaadin}</version>
            </dependency>

            <dependency>
                <groupId>com.vaadin</groupId>
                <artifactId>vaadin-spring-boot-starter</artifactId>
                <version>${version.vaadin}</version>
            </dependency>

            <!-- Hibernate Validator Enum: Hibernate Validator Enum is a module that provides additional validation support for enums in Hibernate Validator, which is the reference implementation
                 of the Java Bean Validation API.
                 Enums are a powerful feature in Java, but they can be difficult to validate properly using the standard Bean Validation API. Hibernate Validator Enum provides a set of additional
                 constraints that can be used to validate enums more easily and effectively.
                 The Hibernate Validator Enum module includes a number of constraints that can be used to validate enums, including @EnumNamePattern, which can be used to ensure that an enum's
                 name matches a specific pattern. It also provides a @ValidEnumSubset constraint that can be used to ensure that an enum value is a valid subset of a given set of enum values.
                 By using the Hibernate Validator Enum module, developers can more easily validate enums in their applications, reducing the likelihood of errors and bugs caused by invalid enum
                 values. It is typically included as a dependency in a project's pom.xml (Maven) or build.gradle (Gradle) file when using Hibernate Validator. -->
            <!-- See: https://github.com/fuxingloh/hibernate-validator-enum -->
            <!-- See: https://www.baeldung.com/javax-validations-enums -->
            <dependency>
                <groupId>dev.fuxing</groupId>
                <artifactId>hibernate-validator-enum</artifactId>
                <version>${version.hibernate.validator}</version>
            </dependency>

            <!-- Lombok: Lombok is a Java library that provides a set of annotations and code generators that help to reduce boilerplate code in Java classes. It is essentially a tool that
                 simplifies Java code by automating repetitive tasks and providing a more concise syntax for common operations.
                 Lombok provides a set of annotations that can be used to generate getter and setter methods, constructors, equals and hash code methods, and other common Java class methods. It also
                 provides a set of annotations for logging, null checks, and other common operations.
                 By using Lombok annotations, developers can write less code and make their code more concise and readable. This can help to reduce the amount of code that needs to be written and
                 maintained, and can also help to reduce the likelihood of errors caused by repetitive or boilerplate code. -->
            <!-- See: https://projectlombok.org -->
            <!-- See: https://www.baeldung.com/intro-to-project-lombok -->
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <version>${version.lombok}</version>
            </dependency>
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok-mapstruct-binding</artifactId>
                <version>${version.lombok-mapstruct}</version>
            </dependency>

            <!-- Jackson Annotations: This project contains general purpose annotations for Jackson Data Processor, used on value and handler types. The only annotations not included are ones that
                 require dependency to the Databind package. Note that only annotations themselves (and related value classes) are included, but no functionality that uses annotations. -->
            <!-- See: https://github.com/FasterXML/jackson-annotations -->
            <!-- Note: Necessary if using the testcontainers dependencies! -->
            <dependency>
                <groupId>com.fasterxml.jackson.core</groupId>
                <artifactId>jackson-annotations</artifactId>
                <version>${version.jackson}</version>
            </dependency>

            <!-- Apache Commons Lang: Apache Commons Lang is a set of open-source Java libraries that provides a range of utility classes and methods for working with common programming tasks, such
                 as string manipulation, reflection, concurrency, and more. commons-lang3 is the latest version of the library, with several improvements and new features over its predecessor,
                 commons-lang.
                 The commons-lang3 library provides a variety of classes and methods that simplify common programming tasks and help to avoid common errors. Some of the key features of the library
                 include:
                 * String manipulation utilities, such as methods for substring, padding, trimming, and more.
                 * Reflection utilities, such as methods for accessing and modifying fields and methods of Java objects.
                 * Concurrency utilities, such as classes for working with locks, semaphores, and thread pools.
                 * Date and time utilities, such as classes for working with dates, calendars, and durations.
                 * Math utilities, such as classes for working with fractions, primes, and random numbers.
                 * Exception handling utilities, such as classes for wrapping and rethrowing exceptions. -->
            <!-- See: https://github.com/apache/commons-lang -->
            <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-lang3</artifactId>
                <version>${version.apache.commons-lang3}</version>
            </dependency>

            <!-- Apache Commons IO: Apache Commons IO is a set of open-source Java libraries that provides a range of utility classes and methods for working with input/output (IO) operations. It
                 provides a variety of classes and methods that simplify common IO tasks and help to avoid common errors.
                 The commons-io library includes utilities for working with files and directories, including methods for copying, moving, deleting, and comparing files, as well as classes for working
                 with file filters and file monitors. It also includes utilities for working with input and output streams, such as classes for reading and writing text and binary data, as well as
                 classes for compressing and decompressing data.
                 Other features of the commons-io library include classes for working with file encodings and character sets, classes for working with temporary files and directories, and classes
                 for dealing with end-of-line characters. -->
            <!-- See: https://github.com/apache/commons-io-->
            <dependency>
                <groupId>commons-io</groupId>
                <artifactId>commons-io</artifactId>
                <version>${version.apache.commons-io}</version>
            </dependency>

            <!-- Apache Commons Validator: Apache Commons Validator is a set of open-source Java libraries that provides a range of utility classes and methods for validating user input. It provides
                 a variety of classes and methods that simplify common validation tasks and help to avoid common errors.
                 The commons-validator library includes utilities for validating common input types, such as email addresses, phone numbers, credit card numbers, and URLs. It also includes utilities
                 for working with regular expressions, such as classes for compiling and matching regular expressions.
                 Other features of the commons-validator library include classes for validating data types, such as numbers, dates, and booleans, as well as classes for working with postal addresses
                 and internationalized domain names. -->
            <!-- See: https://github.com/apache/commons-validator -->
            <dependency>
                <groupId>commons-validator</groupId>
                <artifactId>commons-validator</artifactId>
                <version>${version.apache.commons.validator}</version>
            </dependency>

            <!-- Moby Names Generator: Moby Names Generator is a library that provides a set of functions for generating random names. It is often used in applications where random names are needed,
                 such as in games, chat applications, or other types of applications where users need to be identified by a unique name.
                 The Moby Names Generator library provides several different functions for generating names, including functions for generating first names, last names, and full names. It also
                 provides functions for generating names based on specific themes or categories, such as names of fruits, animals, or famous people.
                 The library is named after Moby Dick, the famous novel by Herman Melville, and includes a variety of names and words that are inspired by the novel's nautical theme. -->
            <!-- See: https://github.com/schnatterer/moby-names-generator-java -->
            <dependency>
                <groupId>info.schnatterer.moby-names-generator</groupId>
                <artifactId>moby-names-generator</artifactId>
                <version>${version.moby.names}</version>
            </dependency>

            <!-- JavaFaker: Java library that provides utilities for generating fake test data. It allows you to easily create realistic test data for use in unit tests, integration tests, and other
                 testing scenarios.
                 The datafaker library includes utilities for generating fake data in a variety of formats, such as names, addresses, phone numbers, dates, times, and more. It also includes utilities
                 for generating fake data in specific formats, such as email addresses, credit card numbers, and social security numbers.
                 Other features of the datafaker library include support for generating random strings and numbers, generating random data within specific ranges, and customizing the generated data
                 to meet specific testing needs. -->
            <!-- See: https://github.com/datafaker-net/datafaker -->
            <dependency>
                <groupId>net.datafaker</groupId>
                <artifactId>datafaker</artifactId>
                <version>${version.datafaker}</version>
            </dependency>

            <dependency>
                <groupId>org.postgresql</groupId>
                <artifactId>postgresql</artifactId>
                <version>${version.db.postgresql}</version>
                <scope>test</scope>
            </dependency>

        </dependencies>

    </dependencyManagement>

    <build>

        <extensions>

            <extension>
                <groupId>com.gkatzioura.maven.cloud</groupId>
                <artifactId>s3-storage-wagon</artifactId>
                <version>2.3</version>
            </extension>

        </extensions>

        <plugins>

            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>${version.spring.boot}</version>
            </plugin>

            <!-- JAR: Compile the sources. -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>${version.maven.plugin.compiler}</version>
            </plugin>

            <!-- JAR: Create a jar of the test classes. -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>${version.maven.plugin.jar}</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>test-jar</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>

            <!-- JAVADOC: Used to generate the Javadoc JAR file. -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-javadoc-plugin</artifactId>
                <version>${version.maven.plugin.javadoc}</version>
                <configuration>
                    <encoding>${project.build.sourceEncoding}</encoding>
                    <docencoding>${project.build.sourceEncoding}</docencoding>
                    <charset>${project.build.sourceEncoding}</charset>
                    <javadocExecutable>${java.home}/bin/javadoc</javadocExecutable>
                    <sourceFileExcludes>
                        <exclude>**/*Impl.java</exclude>
                    </sourceFileExcludes>
                    <!--                    <additionalOptions>-Werror</additionalOptions> &lt;!&ndash; Turn Javadoc warnings to errors &ndash;&gt;-->
                </configuration>
                <executions>
                    <execution>
                        <id>attach-javadocs</id>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>

            <!-- SOURCE: Used to generate the sources JAR file. -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-source-plugin</artifactId>
                <version>${version.maven.plugin.source}</version>
                <executions>
                    <execution>
                        <id>attach-sources</id>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>

            <!-- SCM: Used to perform Source Control Management actions with Maven. -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-scm-plugin</artifactId>
                <version>${version.maven.plugin.scm}</version>
            </plugin>

            <!-- RELEASE: Used to release a project with Maven. -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-release-plugin</artifactId>
                <version>${version.maven.plugin.release}</version>
                <configuration>
                    <tagNameFormat>@{project.version}</tagNameFormat>
                    <autoVersionSubmodules>true</autoVersionSubmodules>
                    <useReleaseProfile>false</useReleaseProfile>
                </configuration>
            </plugin>

            <!-- SITE: The Site Plugin is used to generate a site for the project. -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-site-plugin</artifactId>
                <version>${version.maven.plugin.site}</version>
            </plugin>

            <!-- INFO REPORTS: The Maven Project Info Reports plugin is used to generate reports information about the project. -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-project-info-reports-plugin</artifactId>
                <version>${version.maven.plugin.project.info.reports}</version>
            </plugin>

            <!-- JACOCO: Java Code Coverage. -->
            <plugin>
                <groupId>org.jacoco</groupId>
                <artifactId>jacoco-maven-plugin</artifactId>
                <version>${version.plugin.maven.jacoco}</version>
            </plugin>

            <!-- SONAR: The Maven Project Sonar plugin is used to execute static analysis on the code. -->
            <plugin>
                <groupId>org.sonarsource.scanner.maven</groupId>
                <artifactId>sonar-maven-plugin</artifactId>
                <version>${version.plugin.maven.sonarscource.scanner}</version>
            </plugin>

            <!-- SUREFIRE: The Maven Project Surefire plugin is used to execute the tests. -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>${version.maven.plugin.surefire}</version>
                <configuration>
                    <includes>
                        <include>**/*UnitTest.java</include>
                    </includes>
                    <excludes>
                        <exclude>**/*IntegrationTest.java</exclude>
                    </excludes>
                </configuration>
            </plugin>

            <!-- FAILSAFE: For integration tests. -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-failsafe-plugin</artifactId>
                <version>${version.maven.plugin.failsafe}</version>
                <configuration>
                    <includes>
                        <include>**/*IntegrationTest.java</include>
                    </includes>
                    <excludes>
                        <exclude>**/*UnitTest.java</exclude>
                    </excludes>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>integration-test</goal>
                            <goal>verify</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-antrun-plugin</artifactId>
                <version>3.0.0</version>
                <executions>
                    <execution>
                        <id>antrun-plugin</id>
                        <phase>validate</phase>
                        <goals>
                            <goal>run</goal>
                        </goals>
                        <!--                        <configuration>-->
                        <!--                            <target>-->
                        <!--                                <echo>'sonar.coverage.jacoco.xmlReportPaths': ${sonar.coverage.jacoco.xmlReportPaths}</echo>-->
                        <!--                            </target>-->
                        <!--                        </configuration>-->
                    </execution>
                </executions>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-help-plugin</artifactId>
                <version>3.2.0</version>
                <executions>
                    <execution>
                        <id>show-profiles</id>
                        <phase>compile</phase>
                        <goals>
                            <goal>active-profiles</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>

        </plugins>

        <resources>
            <resource>
                <!-- Allow resource filtering for variable substitution -->
                <directory>src/main/resources</directory>
                <filtering>true</filtering>
            </resource>

            <!-- Allow resource filtering for variable substitution -->
            <resource>
                <directory>src/test/resources</directory>
                <filtering>true</filtering>
            </resource>
        </resources>

    </build>

    <profiles>

        <profile>
            <id>java.08</id>
            <activation>
                <activeByDefault>false</activeByDefault>
            </activation>
            <properties>
                <maven.compiler.release>8</maven.compiler.release>
                <maven.compiler.source>8</maven.compiler.source>
                <maven.compiler.target>8</maven.compiler.target>
            </properties>
        </profile>

        <profile>
            <id>java.09</id>
            <activation>
                <activeByDefault>false</activeByDefault>
            </activation>
            <properties>
                <maven.compiler.release>9</maven.compiler.release>
                <maven.compiler.source>9</maven.compiler.source>
                <maven.compiler.target>9</maven.compiler.target>
            </properties>
        </profile>

        <profile>
            <id>java.11</id>
            <activation>
                <activeByDefault>false</activeByDefault>
            </activation>
            <properties>
                <maven.compiler.release>11</maven.compiler.release>
                <maven.compiler.source>11</maven.compiler.source>
                <maven.compiler.target>11</maven.compiler.target>
            </properties>
        </profile>

        <profile>
            <id>java.13</id>
            <activation>
                <activeByDefault>false</activeByDefault>
            </activation>
            <properties>
                <maven.compiler.release>13</maven.compiler.release>
                <maven.compiler.source>13</maven.compiler.source>
                <maven.compiler.target>13</maven.compiler.target>
            </properties>
        </profile>

        <profile>
            <id>java.15</id>
            <activation>
                <activeByDefault>false</activeByDefault>
            </activation>
            <properties>
                <maven.compiler.source>15</maven.compiler.source>
                <maven.compiler.target>15</maven.compiler.target>
                <maven.compiler.release>15</maven.compiler.release>
            </properties>
        </profile>

        <profile>
            <id>java.16</id>
            <activation>
                <activeByDefault>false</activeByDefault>
            </activation>
            <properties>
                <maven.compiler.source>16</maven.compiler.source>
                <maven.compiler.target>16</maven.compiler.target>
                <maven.compiler.release>16</maven.compiler.release>
            </properties>
        </profile>

        <profile>
            <id>java.17</id>
            <activation>
                <activeByDefault>false</activeByDefault>
            </activation>
            <properties>
                <maven.compiler.source>17</maven.compiler.source>
                <maven.compiler.target>17</maven.compiler.target>
                <maven.compiler.release>17</maven.compiler.release>
            </properties>
        </profile>

        <profile>
            <id>java.19</id>
            <activation>
                <activeByDefault>false</activeByDefault>
            </activation>
            <properties>
                <maven.compiler.source>19</maven.compiler.source>
                <maven.compiler.target>19</maven.compiler.target>
                <maven.compiler.release>19</maven.compiler.release>
            </properties>
        </profile>

        <profile>
            <id>java.20</id>
            <activation>
                <activeByDefault>false</activeByDefault>
            </activation>
            <properties>
                <maven.compiler.source>20</maven.compiler.source>
                <maven.compiler.target>20</maven.compiler.target>
                <maven.compiler.release>20</maven.compiler.release>
            </properties>
        </profile>

        <profile>
            <id>java.21</id>
            <activation>
                <activeByDefault>false</activeByDefault>
            </activation>
            <properties>
                <maven.compiler.source>21</maven.compiler.source>
                <maven.compiler.target>21</maven.compiler.target>
                <maven.compiler.release>21</maven.compiler.release>
            </properties>
        </profile>

        <profile>
            <id>hemajoo.env.local</id>
            <activation>
                <activeByDefault>false</activeByDefault>
            </activation>
            <properties>
                <hemajoo.env.active>local</hemajoo.env.active>
            </properties>
        </profile>

        <profile>
            <id>hemajoo.env.dev</id>
            <activation>
                <activeByDefault>false</activeByDefault>
            </activation>
            <properties>
                <hemajoo.env.active>dev</hemajoo.env.active>
            </properties>
        </profile>

        <profile>
            <id>hemajoo.env.uat</id>
            <activation>
                <activeByDefault>false</activeByDefault>
            </activation>
            <properties>
                <hemajoo.env.active>stage</hemajoo.env.active>
            </properties>
        </profile>

        <profile>
            <id>hemajoo.env.prod</id>
            <activation>
                <activeByDefault>false</activeByDefault>
            </activation>
            <properties>
                <hemajoo.env.active>prod</hemajoo.env.active>
            </properties>
            <dependencies>
                <dependency>
                    <groupId>com.vaadin</groupId>
                    <artifactId>vaadin-core</artifactId>
                    <exclusions>
                        <exclusion>
                            <groupId>com.vaadin</groupId>
                            <artifactId>vaadin-dev</artifactId>
                        </exclusion>
                    </exclusions>
                </dependency>
            </dependencies>
            <build>
                <plugins>
                    <plugin>
                        <groupId>com.vaadin</groupId>
                        <artifactId>vaadin-maven-plugin</artifactId>
                        <version>${version.vaadin}</version>
                        <executions>
                            <execution>
                                <goals>
                                    <goal>build-frontend</goal>
                                </goals>
                                <phase>compile</phase>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>
            </build>
        </profile>

    </profiles>

</project>
